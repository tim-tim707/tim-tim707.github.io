<!DOCTYPE html>
<html lang="en">

<head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>SWEP1RCR decompilation article</title>
       <link rel="stylesheet" href="./style.css">
       <link rel="icon" href="./favicon.ico" type="image/x-icon">
       <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">

       <!-- Code Highlight -->
       <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
       <script>hljs.highlightAll();</script>
</head>

<body>
       <main>
              <text>
                     When I was younger, I use to play the old Star Wars games such as Rogue
                     Squadron and Star Wars Racer.
                     I've always enjoyed these games, and at some point I
                     decided I wanted to remaster Star Wars Racer, because the game was great
                     but the graphics were getting dated.
                     At that time, it was just a
                     childhood dream that I kept in the back of my head. I just thought it
                     would be cool to do it but never started it.

                     I joined the community in 2019, after playing the full campaign again. This is when I discovered
                     multiplayer and we would play tournament regularly.

                     Fast forward a couple of years and I'm a software engineer student.
                     During one of my year, I met a younger student that was into reverse engineering and low level
                     programming talking about how he helped in the decompilation and recompilation of <a
                            href="https://github.com/zeldaret/oot"> Zelda Ocarina of time</a>.
                     I thought that if he was able to do it being younger than me, I had no excuses not starting my own
                     project (+ he could help me begin since he knows stuff already). It was also a time in my studies
                     where I had a more free time than before, so I started the decompilation repository for the game
                     the 28 January 2023, just over two years from now.
                     My overall plan was: Understand the game well enough to replace the original renderer by our own,
                     then make pretty modern graphics. I had already learn the basics of graphics programming such as
                     OpenGL and shader programming, as well as PBR rendering and Image based Lighting, and it's a
                     programming field I really enjoyed. I had, however, no competency in Reverse Engineering and
                     decompilation, and only a very basic understanding of assembly. Well, if my friend learned it, what
                     stops me from learning it too ?

                     Looking at the community efforts, there
                     was already some work done on decompilation and porting such as
                     openswe1r(https://github.com/OpenSWE1R/openswe1r) and
                     swe1r-re(https://github.com/OpenSWE1R/swe1r-re). The first step of the
                     plan would be to aggregate all the work done here and there into a big
                     decompilation project, which would help me go faster, help
                     others to reduce the duplication of work, and be an easier introduction to reverse engineering for
                     me.
                     I would thus base my work from where JayFoxRox stopped, the previous guy working on decompilation.
                     He had already left about 4 years ago at
                     the time, but left some valuable notes about various function of the game.
                     This was perfect for me ! There was already some work done that I could compare on Ghidra and see
                     the back in forth between assembly and the C code equivalent he made.
                     Similarly, LightningPirate had a private repository being untouched for about 2 years where he also
                     had notes, which he happily shared to me.

                     Starting from these notes was really helpful since I didn't have to start from scratch and learn
                     everything at once.
                     For the reverse engineer part, I started with the basics such as dumping all the strings to
                     see if anything was popping out. Indeed, some strings already give valuable bits of information

                     // Some debug strings left in the executable
                     D:\devel.QA5\pc_gnome\SpecPlat\rdroid_gnome\Source\elfCallback.c
                     elfControl_ReplaceMapping(cid, fncStr, whichOne, bAnalogCapture, sign, lastBinding)
                     elfControl_ReplaceMapping(cid, TXT_ROLL_RIGHT, whichOne, 1, -sign, lastBinding)
                     elfControl_ReplaceMapping(cid, fncStr, whichOne, bAnalogCapture, 0, controllerBinding)
                     D:\devel.QA5\pc_gnome\SpecPlat\rdroid_gnome\Source\elfControl.c
                     elfSaveLoad_SaveThisGameStruct()
                     D:\devel.QA5\pc_gnome\SpecPlat\rdroid_gnome\Source\elfSaveLoad.c

                     // Most importantly, mention of Jones3D and tVBuffer structure
                     D:\devel.QA5\pc_gnome\SpecPlat\rdroid_gnome\Jones3D\Libs\Std\Win95\stdDisplay.c
                     Unable to allocate memory for new tVBuffer
                     D:\devel.QA5\pc_gnome\SpecPlat\rdroid_gnome\Jones3D\Libs\Std\General\stdColor.c
                     D:\devel.QA5\pc_gnome\SpecPlat\rdroid_gnome\Jones3D\Libs\Std\General\stdBmp.c
                     wKernelJones3D

                     Setting hanger state to HANGAR_STATE_MAIN_MENU
                     Setting hanger state to HANGAR_STATE_SELECT_PLANET
                     Setting hanger state to HANGAR_STATE_SELECT_TRACK
                     Setting hanger state to HANGAR_STATE_DONTCARE

                     // + CLSID for Windows Pimpl IUnknown Interface for a3dapi.dll, D3D, DInput, Dplay

                     // Also this joke lost to the compilation that got trimmed. We'll never know the punchline
                     ---PC---~nStop me if you've ~nheard this one. A jawa and ewok walk into a bar. The ewok says ~n'Hey
                     bartender, get ~nme a--' but stops, ~namazed, when the jawa grabs his cloak and ~nstarts pointing
                     at the&lt;truncated here&gt;

                     Appart from In-Game strings easily recognizable, some debug path that
                     should not have been there spiked my curiosity. Google would point to
                     OpenJKDF2(https://github.com/shinyquagsire23/OpenJKDF2), a very similar
                     project than the one I was attempting, but already much more advanced.
                     It turns out Jedi Knight Dark Forces 2 has some similar engine library function than what we
                     can find in SWR. Let's just try to match every JKDF2 function with ours !
                     Speaking with the members of the JKDF2 community, one member, Urgon informed me about the
                     Jones3D being part of the game Indiana Jones and the Infernal
                     Machine(https://en.wikipedia.org/wiki/Indiana_Jones_and_the_Infernal_Machine) released by LucasArt
                     for N64. He was working on a decompilation for the later and provided me with additionnal
                     informations about the engine. Notice that the game was released for N64, and that Star Wars Racer
                     was also released on both PC and N64.

                     The math library are almost identical for the 3 games, which can be explained
                     by LucasArt developping so much games that engine reuse would be common
                     practice, like in many studios at the time.

                     With the merging going at a good pace, some pure functions would
                     already be decompiled, which help understand the functions above, and so
                     on. This provide a compounding effect that makes decompilation faster and faster (As well as
                     my
                     skills improving in understanding assembly and decompilation)
                     // TODO: vector and matrix pure functions
                     TODO: portability of system
                     // functions

                     Now is a good time to talk about the game (From the wikipedia article and our own research):
                     Designed to be as portable as possible from the beginning. Released on
                     Windows with D3D, N64, GBC, Macintosh with OpenGL, Dreamcast and was later ported to Switch,
                     Playstation 4 and Xbox One. Windows multiplayer uses the IPX protocol (now deprecated),
                     while Mac uses TCP/IP. Some code was shared with Star Wars Jedi Knight Dark Forces 2 (which matches
                     what I found with debug strings).

                     Thats also at that time that I decided more clearly of what the decompilation project should be,
                     after talking to friends.
                     On the Legal aspect, I see that reverse engineering is a grey area as long as no harm is done. I
                     also decided to not decompile the whole game and not try for matching decompilation since this
                     could be enabling piracy. On the other hand, the modding scene for Star Wars BattleFront 2 (2005
                     edition on PC and PS2) was really big and flourishing, and they were providing great value for
                     players. That's what I wanted to do for Star Wars Racer, even though the community is much smaller.

                     The following months would be a mix of merging knowledge we have found
                     here and there about the game, and plain boring decompilation, scraping
                     every bit we can so that we can make sense of what is going on where.
                     On ghidra, that would be either trying to find a small function that is sufficiently independent to
                     understand it on its own, or find references between global data and functions to infer its use and
                     meaning.
                     Some systems would always be referenced such as the game object
                     management, while others much less (Sound and graphics).

                     Another good approach to understand the inner working of the game would
                     be the IO with config files and assets. Some config files for mappings, sounds, visual quality are
                     parsed by the game into global variables that can be understood and help understand other functions
                     where they are used. All the assets of the game are parsed from 4 binary blobs named modelblock,
                     splineblock, spriteblock and textureblock. The understanding of these files would be essential in
                     understanding the custom format of the 3D models defined in it. This could unlock potential
                     manipulation of in-game assets via decompression-modification-recompression in a tool like blender,
                     as long as the format matches what the game expect. These file and their format would remain a
                     mystery for a lot of time, since their structure were not like the other games.

                     In November 2023, Aphex shared custom code he had to parse the structure of the
                     binary blocks. This gold mine of knowledge helped us tremendously in
                     understanding both the static data of the binary blobs of the game, as
                     well as the parsing logic inside the game. He was working on it for a long time and cross
                     referenced multiple versions of the game to check his script was working properly.
                     He is the one that knows most about the game assets, and was the first to
                     decompress, modify and recompress a binary asset block into the game,
                     which was an important milestone for this project.
                     (https://discord.com/channels/441839750555369474/441842584592056320/1177552168392347648)
                     This also quickly make us discover some hardcoded limits of the game that would be very hard to
                     fix.
                     For example, there is a fixed number of triangles the game can show at once, and a limited number
                     and total byte size for textures. To circumvent these limits, having a separate renderer is much
                     easier and powerful than trying to patch every part of the game that reference them.

                     With math function, camera functions, 3D functions, system functions,
                     our understanding grew enough that one year later, another community
                     member named tilman managed to hook and replace enough functions to run
                     imgui and a d3d api replacement, proving that we had enough
                     decompilation already to start replacing graphics.
                     With this proof of
                     concept working, most of my time went into improving the renderer
                     replacement. After one and a half year of slow an boring decompilation,
                     the fun part of building the gltf renderer was upon us !
                     I wanted
                     support for renderDoc since its a great tool that would greatly help.
                     Unfortunately, the replacement was done with immediate rendering to be
                     as close as possible to the original one.
                     Tilman and I started to swap
                     the d3d rendering for openGL rendering immediate mode at first, then
                     replaced the immediate mode openGL with more modern one, and we had
                     renderDoc support just like that !

                     The following months would be implementing the gltf
                     specification(https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html)
                     with the help of the gltf sample
                     renderer(https://github.com/KhronosGroup/glTF-Sample-Renderer) and the
                     gltf sample models(https://github.com/KhronosGroup/glTF-Sample-Models),
                     which are very high quality source of information

                     Finally, by hooking the `viewport_render` function that renders the
                     scene graph, we can filter the models we want to render them with our
                     own renderer instead. This method is transparent for the game and gives
                     us enough control to replace whatever we want.
              </text>
              <h1>H1</h1>
              <text>
                     How to remaster an old game without the source code.

                     Plan: decompile the game to understand how it works, create a mod to swap the renderer with our own



                     <div>
                            <pre><code class="language-C">
#include &lt;stdio.h&gt;

#include &lt;windows.h&gt;
#include &quot;hook.h&quot;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

// The swr_reimpl.dll entry point

#ifdef WIN32

HWND g_ConsoleWindow = NULL;

bool CreateConsoleWindow()
{
    // Allocate a new console for the calling process
    if (!AllocConsole())
        return false;

    // Get the newly created console window handle
    g_ConsoleWindow = GetConsoleWindow();
    if (g_ConsoleWindow == NULL)
        return false;

    // Redirect standard input, output, and error streams to the console
    freopen_s((FILE**)stdin, "CONIN$", "r", stdin);
    freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
    freopen_s((FILE**)stderr, "CONOUT$", "w", stderr);

    SetConsoleTitleA("SWR CE Debug Console");

    return true;
}
</code></pre>
                     </div>
              </text>
       </main>
</body>

</html>
